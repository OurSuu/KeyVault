const express = require('express');
const app = express();  // ‚úÖ ‡∏ï‡πâ‡∏≠‡∏á‡∏≠‡∏¢‡∏π‡πà‡∏ï‡∏£‡∏á‡∏ô‡∏µ‡πâ‡∏Å‡πà‡∏≠‡∏ô‡πÉ‡∏ä‡πâ app.post

// ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç trust proxy ‡πÉ‡∏´‡πâ‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡πÄ‡∏à‡∏≤‡∏∞‡∏à‡∏á
app.set('trust proxy', process.env.NODE_ENV === 'production' ? 1 : false);

const nodemailer = require('nodemailer');
const sqlite3 = require('sqlite3').verbose();
const bcrypt = require('bcryptjs');
const cors = require('cors');
const path = require('path');
const rateLimit = require('express-rate-limit');

const PORT = process.env.PORT || 3000;

// === ‡∏Å‡∏≥‡∏´‡∏ô‡∏î email ‡∏´‡∏•‡∏±‡∏Å‡∏Ç‡∏≠‡∏á‡πÄ‡∏ß‡πá‡∏ö/‡∏£‡∏´‡∏±‡∏™‡∏ú‡πà‡∏≤‡∏ô‡∏à‡∏≤‡∏Å environment variable ===
const MAIN_EMAIL = process.env.EMAIL || 'Noppanatyukun@gmail.com';
const EMAIL_PASSWORD = process.env.EMAIL_PASSWORD || 'zlcs jumf cayg wmgz';

// ====== Middleware (‡∏Ç‡∏∂‡πâ‡∏ô‡∏ö‡∏ô‡∏™‡∏∏‡∏î ‡∏Å‡πà‡∏≠‡∏ô‡∏ó‡∏∏‡∏Å route) ======
app.use(cors());
app.use(express.json());
app.use(express.urlencoded({ extended: true }));

// === OTP/Email Routes: Improved OtpManager Usage ===

class OtpManager {
  constructor() {
    this.otpStore = new Map();
    this.otpCooldown = new Map();
    this.cleanupInterval = setInterval(() => this.cleanup(), 5 * 60 * 1000); // cleanup every 5 min
  }

  generateOtp(email) {
    const otp = Math.floor(100000 + Math.random() * 900000).toString();
    this.otpStore.set(email, {
      otp,
      expire: Date.now() + 5 * 60 * 1000, // 5 mins
      attempts: 0
    });
    return otp;
  }

  verifyOtp(email, otp) {
    const record = this.otpStore.get(email);
    if (!record) return { valid: false, error: "‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏£‡∏´‡∏±‡∏™ OTP ‡∏ô‡∏µ‡πâ" };

    if (record.expire < Date.now()) {
      this.otpStore.delete(email);
      return { valid: false, error: "‡∏£‡∏´‡∏±‡∏™‡∏´‡∏°‡∏î‡∏≠‡∏≤‡∏¢‡∏∏‡πÅ‡∏•‡πâ‡∏ß" };
    }

    // ‡∏à‡∏≥‡∏Å‡∏±‡∏î‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡∏ó‡∏µ‡πà‡∏•‡∏≠‡∏á
    record.attempts++;
    if (record.attempts > 5) {
      this.otpStore.delete(email);
      return { valid: false, error: "‡∏•‡∏≠‡∏á‡∏£‡∏´‡∏±‡∏™‡πÄ‡∏Å‡∏¥‡∏ô‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏ó‡∏µ‡πà‡∏Å‡∏≥‡∏´‡∏ô‡∏î" };
    }

    if (record.otp !== otp) {
      return { valid: false, error: "‡∏£‡∏´‡∏±‡∏™ OTP ‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á" };
    }

    this.otpStore.delete(email);
    return { valid: true };
  }

  setCooldown(email) {
    this.otpCooldown.set(email, Date.now());
  }

  checkCooldown(email) {
    const lastRequest = this.otpCooldown.get(email);
    if (!lastRequest) return { cooldown: false };

    const now = Date.now();
    if (now - lastRequest < 60000) {
      return {
        cooldown: true,
        remaining: Math.ceil((60000 - (now - lastRequest)) / 1000)
      };
    }
    this.otpCooldown.delete(email);
    return { cooldown: false };
  }

  cleanup() {
    const now = Date.now();
    // Remove expired otps
    for (const [email, record] of this.otpStore.entries()) {
      if (record.expire < now) {
        this.otpStore.delete(email);
      }
    }
    // Remove expired cooldowns
    for (const [email, timestamp] of this.otpCooldown.entries()) {
      if (now - timestamp >= 60000) {
        this.otpCooldown.delete(email);
      }
    }
  }
}

const otpManager = new OtpManager();

// === Resend transporter setup ===
let transporter;

try {
  transporter = nodemailer.createTransport({
    host: "smtp.resend.com",
    port: 465,
    secure: true,
    auth: {
      user: "resend",
      pass: process.env.RESEND_API_KEY,
    },
  });

  transporter.verify(function (error, success) {
    if (error) {
      console.error("‚ùå Email transporter error:", error);
    } else {
      console.log("‚úÖ Resend transporter is ready to send emails");
    }
  });
} catch (error) {
  console.error("‚ùå Failed to create Resend transporter:", error);
  transporter = null;
}

// === ‡∏™‡πà‡∏á OTP ‡πÑ‡∏õ‡∏¢‡∏±‡∏á‡∏≠‡∏µ‡πÄ‡∏°‡∏• (with cooldown & prettier email) ‡∏î‡πâ‡∏ß‡∏¢ otpManager ===
app.post("/api/auth/send-otp", async (req, res) => {
  const { email } = req.body;
  if (!email) return res.status(400).json({ error: "Missing email" });

  console.log('üìß OTP Request for:', email);

  // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö cooldown
  const cooldown = otpManager.checkCooldown(email);
  if (cooldown.cooldown) {
    console.log('‚è≥ OTP Cooldown for:', email, cooldown.remaining);
    return res.status(429).json({
      error: `‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏£‡∏≠ ${cooldown.remaining} ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ‡∏Å‡πà‡∏≠‡∏ô‡∏Ç‡∏≠ OTP ‡πÉ‡∏´‡∏°‡πà`,
      cooldown: cooldown.remaining
    });
  }

  // ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤ cooldown
  otpManager.setCooldown(email);
  const otp = otpManager.generateOtp(email);

  console.log('üîê Generated OTP:', otp, 'for:', email);

  try {
    console.log('üì§ Attempting to send email...');
    
    await transporter.sendMail({
      from: `"KeyVault" <${MAIN_EMAIL}>`,
      to: email,
      subject: "üîê KeyVault - Email Verification Code",
      html: `
        <div style="font-family:Arial;padding:16px;max-width:500px;margin:0 auto;background:#f8fafc;border-radius:8px;border:1px solid #e2e8f0;">
          <div style="background:linear-gradient(90deg,#6366f1,#8b5cf6);padding:20px;border-radius:8px 8px 0 0;text-align:center;">
            <h1 style="color:white;margin:0;font-size:24px;">üîê KeyVault</h1>
          </div>
          <div style="padding:20px;">
            <h2 style="color:#1e293b;margin-top:0;">‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô‡∏≠‡∏µ‡πÄ‡∏°‡∏•‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì</h2>
            <p style="color:#475569;font-size:16px;line-height:1.5;">‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÉ‡∏ä‡πâ‡∏£‡∏´‡∏±‡∏™‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô‡∏î‡πâ‡∏≤‡∏ô‡∏•‡πà‡∏≤‡∏á‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏î‡∏≥‡πÄ‡∏ô‡∏¥‡∏ô‡∏Å‡∏≤‡∏£‡∏™‡∏°‡∏±‡∏Ñ‡∏£‡∏ö‡∏±‡∏ç‡∏ä‡∏µ KeyVault:</p>
            <div style="background:#f1f5f9;border:2px dashed #cbd5e1;border-radius:8px;padding:15px;text-align:center;margin:20px 0;">
              <div style="font-size:32px;font-weight:bold;letter-spacing:8px;color:#1e293b;">${otp}</div>
            </div>
            <p style="color:#64748b;font-size:14px;text-align:center;">
              ‚ö†Ô∏è ‡∏£‡∏´‡∏±‡∏™‡∏ô‡∏µ‡πâ‡∏à‡∏∞‡∏´‡∏°‡∏î‡∏≠‡∏≤‡∏¢‡∏∏‡πÉ‡∏ô 5 ‡∏ô‡∏≤‡∏ó‡∏µ<br>
              ‚ùå ‡∏´‡∏≤‡∏Å‡∏Ñ‡∏∏‡∏ì‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡∏Ç‡∏≠‡∏£‡∏´‡∏±‡∏™‡∏ô‡∏µ‡πâ ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏û‡∏¥‡∏Å‡πÄ‡∏â‡∏¢‡∏ï‡πà‡∏≠‡∏≠‡∏µ‡πÄ‡∏°‡∏•‡∏ô‡∏µ‡πâ
            </p>
          </div>
          <div style="background:#f1f5f9;padding:15px;border-radius:0 0 8px 8px;text-align:center;border-top:1px solid #e2e8f0;">
            <p style="color:#64748b;font-size:12px;margin:0;">
              ¬© ${new Date().getFullYear()} KeyVault. All rights reserved.
            </p>
          </div>
        </div>
      `,
    });

    console.log('‚úÖ OTP Email sent successfully to:', email);
    
    res.json({
      success: true,
      message: "‡∏™‡πà‡∏á‡∏£‡∏´‡∏±‡∏™ OTP ‡πÑ‡∏õ‡∏¢‡∏±‡∏á‡∏≠‡∏µ‡πÄ‡∏°‡∏•‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì‡πÅ‡∏•‡πâ‡∏ß",
      cooldown: 60
    });
  } catch (err) {
    // ‡∏•‡∏ö cooldown ‡∏ñ‡πâ‡∏≤‡∏™‡πà‡∏á‡πÑ‡∏°‡πà‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à
    otpManager.otpCooldown.delete(email);

    console.error("‚ùå OTP Email failed:", err.message);
    console.error("Full error:", err);
    
    res.status(500).json({ 
      error: "‡∏™‡πà‡∏á‡∏≠‡∏µ‡πÄ‡∏°‡∏•‡πÑ‡∏°‡πà‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à",
      debug: err.message 
    });
  }
});

// ‡πÄ‡∏û‡∏¥‡πà‡∏° endpoint ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö cooldown OTP
app.get("/api/auth/cooldown/:email", (req, res) => {
  const { email } = req.params;
  const cooldown = otpManager.checkCooldown(email);
  if (cooldown.cooldown) {
    return res.json({
      cooldown: true,
      remaining: cooldown.remaining
    });
  }
  res.json({ cooldown: false });
});

// === ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö OTP (‡∏õ‡∏£‡∏±‡∏ö‡πÉ‡∏ä‡πâ otpManager) ===
app.post("/api/auth/verify-otp", (req, res) => {
  const { email, otp } = req.body;
  const result = otpManager.verifyOtp(email, otp);

  if (!result.valid) {
    return res.status(400).json({ error: result.error });
  }

  return res.json({ success: true });
});

// === Forgot Password === (‡∏ï‡πâ‡∏≠‡∏á‡∏≠‡∏¢‡∏π‡πà‡∏´‡∏•‡∏±‡∏á transporter ‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÅ‡∏•‡πâ‡∏ß‡πÄ‡∏ó‡πà‡∏≤‡∏ô‡∏±‡πâ‡∏ô)
app.post("/api/auth/forgot-password", async (req, res) => {
  const { email } = req.body;
  if (!email) return res.status(400).json({ error: "Missing email" });

  db.get("SELECT id, email FROM users WHERE email = ?", [email], async (err, user) => {
    if (err) return res.status(500).json({ error: "Database error" });
    if (!user) return res.status(404).json({ error: "‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏ö‡∏±‡∏ç‡∏ä‡∏µ‡∏ô‡∏µ‡πâ‡πÉ‡∏ô‡∏£‡∏∞‡∏ö‡∏ö" });

    // ‡∏™‡∏£‡πâ‡∏≤‡∏á token ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö reset (random)
    const resetToken = Math.random().toString(36).substring(2, 10);
    const expire = Date.now() + 1000 * 60 * 15; // 15 ‡∏ô‡∏≤‡∏ó‡∏µ

    if (!global.resetTokens) global.resetTokens = new Map();
    global.resetTokens.set(resetToken, { email, expire });

    // üî• ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡∏•‡∏¥‡∏á‡∏Å‡πå‡πÉ‡∏´‡πâ‡∏ï‡∏£‡∏á‡∏Å‡∏±‡∏ö‡∏ä‡∏∑‡πà‡∏≠‡πÑ‡∏ü‡∏•‡πå‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì
    const resetLink = `http://localhost:${PORT}/reset-password.htm?token=${resetToken}`;

    try {
      await transporter.sendMail({
        from: `"KeyVault Support" <${MAIN_EMAIL}>`,
        to: email,
        subject: "üîê Reset your KeyVault password",
        html: `
          <div style="font-family:Arial;padding:16px;max-width:500px;margin:0 auto;background:#f8fafc;border-radius:8px;border:1px solid #e2e8f0;">
            <h2 style="color:#1e293b;">Reset Your Password</h2>
            <p style="color:#475569;">‡∏Ñ‡∏•‡∏¥‡∏Å‡∏•‡∏¥‡∏á‡∏Å‡πå‡∏î‡πâ‡∏≤‡∏ô‡∏•‡πà‡∏≤‡∏á‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏£‡∏µ‡πÄ‡∏ã‡πá‡∏ï‡∏£‡∏´‡∏±‡∏™‡∏ú‡πà‡∏≤‡∏ô‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì (‡∏†‡∏≤‡∏¢‡πÉ‡∏ô 15 ‡∏ô‡∏≤‡∏ó‡∏µ)</p>
            <a href="${resetLink}" style="display:inline-block;margin:15px 0;padding:12px 20px;background:#3b82f6;color:white;border-radius:6px;text-decoration:none;">Reset Password</a>
            <p style="font-size:12px;color:#64748b;">‡∏´‡∏≤‡∏Å‡∏Ñ‡∏∏‡∏ì‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡∏£‡πâ‡∏≠‡∏á‡∏Ç‡∏≠‡∏Å‡∏≤‡∏£‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏£‡∏´‡∏±‡∏™‡∏ú‡πà‡∏≤‡∏ô ‡πÇ‡∏õ‡∏£‡∏î‡∏•‡∏∞‡πÄ‡∏ß‡πâ‡∏ô‡∏≠‡∏µ‡πÄ‡∏°‡∏•‡∏ô‡∏µ‡πâ</p>
          </div>
        `,
      });
      res.json({ success: true });
    } catch (err) {
      console.error("Email send failed:", err);
      res.status(500).json({ error: "‡∏™‡πà‡∏á‡∏≠‡∏µ‡πÄ‡∏°‡∏•‡πÑ‡∏°‡πà‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à" });
    }
  });
});

app.post("/api/auth/reset-password", async (req, res) => {
  const { token, newPassword } = req.body;
  if (!token || !newPassword) return res.status(400).json({ error: "‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÑ‡∏°‡πà‡∏Ñ‡∏£‡∏ö" });

  const data = global.resetTokens?.get(token);
  if (!data) return res.status(400).json({ error: "‡πÇ‡∏ó‡πÄ‡∏Ñ‡πá‡∏ô‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á‡∏´‡∏£‡∏∑‡∏≠‡∏´‡∏°‡∏î‡∏≠‡∏≤‡∏¢‡∏∏" });
  if (Date.now() > data.expire) {
    global.resetTokens.delete(token);
    return res.status(400).json({ error: "‡πÇ‡∏ó‡πÄ‡∏Ñ‡πá‡∏ô‡∏´‡∏°‡∏î‡∏≠‡∏≤‡∏¢‡∏∏" });
  }

  const hashed = await bcrypt.hash(newPassword, 12);
  db.run("UPDATE users SET password = ? WHERE email = ?", [hashed, data.email], (err) => {
    if (err) return res.status(500).json({ error: "Database error" });
    global.resetTokens.delete(token);
    res.json({ success: true, message: "‡∏£‡∏µ‡πÄ‡∏ã‡πá‡∏ï‡∏£‡∏´‡∏±‡∏™‡∏ú‡πà‡∏≤‡∏ô‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à" });
  });
});
// === END OTP/Email setup ===

// Debug endpoint to check current OTPs
app.get("/api/debug/otp-store", (req, res) => {
  const otps = [];
  for (const [email, data] of otpManager.otpStore.entries()) {
    otps.push({
      email: email,
      otp: data.otp,
      expire: new Date(data.expire).toISOString(),
      attempts: data.attempts
    });
  }
  
  res.json({
    otp_count: otpManager.otpStore.size,
    cooldown_count: otpManager.otpCooldown.size,
    otps: otps
  });
});

app.use(express.static(__dirname));

// Rate limiting
const limiter = rateLimit({
  windowMs: 15 * 60 * 1000,
  max: 100
});
app.use(limiter);

// Database initialization
const db = new sqlite3.Database('./keyvault.db', (err) => {
  if (err) {
    console.error('Error opening database:', err);
  } else {
    console.log('Connected to SQLite database');
    initializeDatabase();
    // ===== ‡∏£‡∏∞‡∏ö‡∏ö‡∏ñ‡∏±‡∏á‡∏Ç‡∏¢‡∏∞ ‡πÄ‡∏û‡∏¥‡πà‡∏° field deleted, deleted_at ‡∏ñ‡πâ‡∏≤‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏°‡∏µ =====
    db.run(`ALTER TABLE codes ADD COLUMN deleted BOOLEAN DEFAULT 0`, (err) => {
      if (err) {
        console.log('Field deleted might already exist');
      }
    });
    db.run(`ALTER TABLE codes ADD COLUMN deleted_at DATETIME`, (err) => {
      if (err) {
        console.log('Field deleted_at might already exist');
      }
    });
    // ‡πÄ‡∏û‡∏¥‡πà‡∏° deleted, deleted_at ‡πÉ‡∏ô categories ‡∏ñ‡πâ‡∏≤‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏°‡∏µ
    db.run(`ALTER TABLE categories ADD COLUMN deleted BOOLEAN DEFAULT 0`, (err) => {
      if (err) {
        console.log('Field deleted (categories) might already exist');
      }
    });
    db.run(`ALTER TABLE categories ADD COLUMN deleted_at DATETIME`, (err) => {
      if (err) {
        console.log('Field deleted_at (categories) might already exist');
      }
    });
  }
});

function initializeDatabase() {
  // Users table
  db.run(`CREATE TABLE IF NOT EXISTS users (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    email TEXT UNIQUE NOT NULL,
    password TEXT NOT NULL,
    name TEXT,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP
  )`);

  // Categories table - ‡πÉ‡∏ä‡πâ sing ‡πÅ‡∏ó‡∏ô slug
  db.run(`CREATE TABLE IF NOT EXISTS categories (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    user_id INTEGER NOT NULL,
    name TEXT NOT NULL,
    sing TEXT NOT NULL,  -- ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÄ‡∏õ‡πá‡∏ô sing
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    deleted BOOLEAN DEFAULT 0,
    deleted_at DATETIME,
    FOREIGN KEY (user_id) REFERENCES users (id) ON DELETE CASCADE,
    UNIQUE(user_id, name)
  )`);

  // Codes table
  db.run(`CREATE TABLE IF NOT EXISTS codes (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    user_id INTEGER NOT NULL,
    category TEXT NOT NULL,
    name TEXT NOT NULL,
    code TEXT NOT NULL,
    description TEXT,
    status TEXT DEFAULT 'active',
    expires_at DATETIME,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    deleted BOOLEAN DEFAULT 0,
    deleted_at DATETIME,
    FOREIGN KEY (user_id) REFERENCES users (id) ON DELETE CASCADE
  )`);

  // ‡πÄ‡∏õ‡∏¥‡∏î‡πÉ‡∏ä‡πâ Foreign Keys
  db.run('PRAGMA foreign_keys = ON');
}

// Authentication middleware - rewritten for debug header logging and clearer structure
const authenticateToken = (req, res, next) => {
  let authHeader = req.headers['authorization'];

  // üîç DEBUG: Log all headers
  console.log('üîç ALL HEADERS:', req.headers);
  console.log('üîç AUTH HEADER:', authHeader);

  if (!authHeader) {
    console.log('‚ùå No authorization header found');
    return res.status(401).json({ error: 'Access token required' });
  }

  authHeader = String(authHeader).trim();

  let token = '';
  if (authHeader.startsWith('Bearer ')) {
    token = authHeader.substring(7).trim();
  } else {
    token = authHeader;
  }

  console.log('üîç EXTRACTED TOKEN:', token);

  if (!token) {
    console.log('‚ùå Token is empty after extraction');
    return res.status(401).json({ error: 'Access token required' });
  }

  // ‡πÉ‡∏ô‡∏£‡∏∞‡∏ö‡∏ö‡∏ô‡∏µ‡πâ token ‡∏Ñ‡∏∑‡∏≠ id ‡∏Ç‡∏≠‡∏á user (‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Å‡∏≤‡∏£ sign/jwt ‡∏à‡∏£‡∏¥‡∏á)
  const userId = parseInt(token, 10);
  if (isNaN(userId) || !isFinite(userId)) {
    console.log('Invalid token format:', token);
    return res.status(401).json({ error: 'Invalid token' });
  }

  db.get('SELECT id, email FROM users WHERE id = ?', [userId], (err, user) => {
    if (err) {
      console.error('Database error in auth:', err);
      return res.status(500).json({ error: 'Database error' });
    }
    if (!user) {
      console.log('No user found for token:', token);
      return res.status(401).json({ error: 'Invalid token' });
    }
    req.userId = userId;
    req.user = user;
    console.log('Authentication successful for user:', user.email);
    next();
  });
};

// ‡πÄ‡∏û‡∏¥‡πà‡∏° route ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö debug token
app.get('/api/debug/auth', authenticateToken, (req, res) => {
  res.json({
    message: 'Token is valid',
    user: req.user,
    userId: req.userId
  });
});

// Route ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö token ‡πÇ‡∏î‡∏¢‡πÑ‡∏°‡πà‡∏ï‡πâ‡∏≠‡∏á authentication
app.get('/api/debug/token-check', (req, res) => {
  let authHeader = req.headers['authorization'];
  if (typeof authHeader !== 'string') authHeader = '';
  authHeader = authHeader.trim();

  let token = '';
  if (authHeader.length === 0) {
    token = '';
  } else if (/^Bearer\s+/i.test(authHeader)) {
    token = authHeader.replace(/^Bearer\s+/i, '').trim();
  } else {
    token = authHeader;
  }

  res.json({
    authHeader: authHeader,
    token: token,
    tokenType: typeof token,
    tokenLength: token ? token.length : 0
  });
});

// ----------- EMAIL DEBUG ENDPOINTS (inserted here) ------------------

// ‡πÄ‡∏û‡∏¥‡πà‡∏° endpoint ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö email configuration
app.get("/api/debug/email-config", (req, res) => {
  const config = {
    EMAIL: process.env.EMAIL || 'Not set',
    EMAIL_PASSWORD: process.env.EMAIL_PASSWORD ? 'Set' : 'Not set',
    MAIN_EMAIL: MAIN_EMAIL,
    has_transporter: !!transporter
  };
  
  console.log('üìß Email Config:', config);
  res.json(config);
});

// ‡πÄ‡∏û‡∏¥‡πà‡∏° endpoint ‡∏ó‡∏î‡∏™‡∏≠‡∏ö‡∏™‡πà‡∏á‡∏≠‡∏µ‡πÄ‡∏°‡∏•
app.get("/api/debug/test-email", async (req, res) => {
  try {
    const testEmail = "test@example.com"; // ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÄ‡∏õ‡πá‡∏ô‡∏≠‡∏µ‡πÄ‡∏°‡∏•‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì
    const otp = "123456";
    
    await transporter.sendMail({
      from: `"KeyVault Test" <${MAIN_EMAIL}>`,
      to: testEmail,
      subject: "üîê KeyVault - Test Email",
      html: `<h1>Test OTP: ${otp}</h1>`,
    });

    res.json({ success: true, message: "Test email sent" });
  } catch (err) {
    console.error("Test email failed:", err);
    res.status(500).json({ error: err.message });
  }
});
// ------------------- END EMAIL DEBUG ENDPOINTS ------------------

// Routes
app.get('/', (req, res) => {
  res.sendFile(path.join(__dirname, 'LoginIndex.htm'));
});

app.get('/main', (req, res) => {
  res.sendFile(path.join(__dirname, 'mainIndex.htm'));
});

// Auth Routes
app.post('/api/auth/register', async (req, res) => {
  const { email, password, name } = req.body;

  if (!email || !password) {
    return res.status(400).json({ error: 'Email and password are required' });
  }

  try {
    db.get('SELECT id FROM users WHERE email = ?', [email], async (err, row) => {
      if (err) {
        return res.status(500).json({ error: 'Database error' });
      }
      if (row) {
        return res.status(400).json({ error: 'User already exists' });
      }

      const hashedPassword = await bcrypt.hash(password, 12);

      db.run('INSERT INTO users (email, password, name) VALUES (?, ?, ?)', 
        [email, hashedPassword, name], function(err) {
        if (err) {
          return res.status(500).json({ error: 'Failed to create user' });
        }

        const userId = this.lastID;

        // ‡∏™‡∏£‡πâ‡∏≤‡∏á default categories ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö user ‡∏ô‡∏µ‡πâ (‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô slug ‡πÄ‡∏õ‡πá‡∏ô sing)
        const defaultCategories = [
          { name: '‡πÄ‡∏Å‡∏°', sing: 'game' },
          { name: '‡∏≠‡∏∑‡πà‡∏ô‡πÜ', sing: 'other' }
        ];

        let categoriesCreated = 0;
        defaultCategories.forEach(cat => {
          db.run('INSERT INTO categories (user_id, name, sing) VALUES (?, ?, ?)',
            [userId, cat.name, cat.sing], function(err) {
            if (err) {
              // ‡πÅ‡∏Ñ‡πà log error ‡πÄ‡∏â‡∏¢‡πÜ ‡πÑ‡∏°‡πà block ‡∏Å‡∏≤‡∏£‡∏™‡∏°‡∏±‡∏Ñ‡∏£
              console.error('Failed to create default category:', err);
            }
            categoriesCreated++;

            // ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏™‡∏£‡πâ‡∏≤‡∏á categories ‡∏Ñ‡∏£‡∏ö‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡πÅ‡∏•‡πâ‡∏ß‡∏Ñ‡πà‡∏≠‡∏¢ response
            if (categoriesCreated === defaultCategories.length) {
              res.json({ 
                message: 'User created successfully',
                userId: userId
              });
            }
          });
        });
      });
    });
  } catch (error) {
    res.status(500).json({ error: 'Server error' });
  }
});

app.post('/api/auth/login', (req, res) => {
  const { email, password } = req.body;

  if (!email || !password) {
    return res.status(400).json({ error: 'Email and password are required' });
  }

  db.get('SELECT * FROM users WHERE email = ?', [email], async (err, user) => {
    if (err) {
      return res.status(500).json({ error: 'Database error' });
    }
    if (!user) {
      return res.status(401).json({ error: 'Invalid email or password' });
    }

    try {
      const isValid = await bcrypt.compare(password, user.password);
      if (!isValid) {
        return res.status(401).json({ error: 'Invalid email or password' });
      }

      res.json({
        message: 'Login successful',
        token: user.id.toString(),
        user: {
          id: user.id,
          email: user.email,
          name: user.name
        }
      });
    } catch (error) {
      res.status(500).json({ error: 'Server error' });
    }
  });
});

/* ====================== Categories Routes + ‡∏ñ‡∏±‡∏á‡∏Ç‡∏¢‡∏∞‡∏´‡∏°‡∏ß‡∏î‡∏´‡∏°‡∏π‡πà ======================== */

// ‡πÉ‡∏´‡∏°‡πà: app.get('/api/categories') ‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö trashed
app.get('/api/categories', authenticateToken, (req, res) => {
  const { trashed } = req.query;
  
  let query = 'SELECT id, name, sing as slug, deleted, deleted_at FROM categories WHERE user_id = ?';
  let params = [req.userId];

  // ‡∏Å‡∏£‡∏≠‡∏á‡∏ï‡∏≤‡∏°‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏ñ‡∏±‡∏á‡∏Ç‡∏¢‡∏∞
  if (trashed === '1') {
    query += ' AND deleted = 1';
  } else {
    query += ' AND (deleted = 0 OR deleted IS NULL)';
  }

  query += ' ORDER BY name';

  db.all(query, params, (err, rows) => {
    if (err) {
      return res.status(500).json({ error: 'Database error' });
    }
    res.json(rows);
  });
});

// ... (rest of file unchanged)